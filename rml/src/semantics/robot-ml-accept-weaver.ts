/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { RobotMlAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './robot-ml-visitor.js';
import { RobotMlVisitor } from './robot-ml-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof RobotMlAstType]?: (node: RobotMlAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class RobotMlAcceptWeaver {
    
    private readonly checks: Weaver = {
        FuncCall: this.weaveFuncCall,
        BoolLiteral: this.weaveBoolLiteral,
        NumLiteral: this.weaveNumLiteral,
        BoolBinaryOperation: this.weaveBoolBinaryOperation,
        NumBinaryOperation: this.weaveNumBinaryOperation,
        BoolUnaryOperation: this.weaveBoolUnaryOperation,
        NumUnaryOperation: this.weaveNumUnaryOperation,
        PrimaryExpression: this.weavePrimaryExpression,
        SensorAccess: this.weaveSensorAccess,
        VariableRef: this.weaveVariableRef,
        FuncDecl: this.weaveFuncDecl,
        Programme: this.weaveProgramme,
        Clock: this.weaveClock,
        Movement: this.weaveMovement,
        SetSpeed: this.weaveSetSpeed,
        Conditional: this.weaveConditional,
        Loop: this.weaveLoop,
        VarAssign: this.weaveVarAssign,
        VarDecl: this.weaveVarDecl,
        StatementList: this.weaveStatementList,
        Bool: this.weaveBool,
        Number_: this.weaveNumber_,
        Void: this.weaveVoid
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveFuncCall(node : InterfaceAST.FuncCall) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitFuncCall(node as unknown as ClassAST.FuncCall); }
    }
    
    weaveBoolLiteral(node : InterfaceAST.BoolLiteral) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBoolLiteral(node as unknown as ClassAST.BoolLiteral); }
    }
    
    weaveNumLiteral(node : InterfaceAST.NumLiteral) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitNumLiteral(node as unknown as ClassAST.NumLiteral); }
    }
    
    weaveBoolBinaryOperation(node : InterfaceAST.BoolBinaryOperation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBoolBinaryOperation(node as unknown as ClassAST.BoolBinaryOperation); }
    }
    
    weaveNumBinaryOperation(node : InterfaceAST.NumBinaryOperation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitNumBinaryOperation(node as unknown as ClassAST.NumBinaryOperation); }
    }
    
    weaveBoolUnaryOperation(node : InterfaceAST.BoolUnaryOperation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBoolUnaryOperation(node as unknown as ClassAST.BoolUnaryOperation); }
    }
    
    weaveNumUnaryOperation(node : InterfaceAST.NumUnaryOperation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitNumUnaryOperation(node as unknown as ClassAST.NumUnaryOperation); }
    }
    
    weavePrimaryExpression(node : InterfaceAST.PrimaryExpression) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitPrimaryExpression(node as unknown as ClassAST.PrimaryExpression); }
    }
    
    weaveSensorAccess(node : InterfaceAST.SensorAccess) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitSensorAccess(node as unknown as ClassAST.SensorAccess); }
    }
    
    weaveVariableRef(node : InterfaceAST.VariableRef) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVariableRef(node as unknown as ClassAST.VariableRef); }
    }
    
    weaveFuncDecl(node : InterfaceAST.FuncDecl) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitFuncDecl(node as unknown as ClassAST.FuncDecl); }
    }
    
    weaveProgramme(node : InterfaceAST.Programme) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitProgramme(node as unknown as ClassAST.Programme); }
    }
    
    weaveClock(node : InterfaceAST.Clock) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitClock(node as unknown as ClassAST.Clock); }
    }
    
    weaveMovement(node : InterfaceAST.Movement) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitMovement(node as unknown as ClassAST.Movement); }
    }
    
    weaveSetSpeed(node : InterfaceAST.SetSpeed) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitSetSpeed(node as unknown as ClassAST.SetSpeed); }
    }
    
    weaveConditional(node : InterfaceAST.Conditional) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitConditional(node as unknown as ClassAST.Conditional); }
    }
    
    weaveLoop(node : InterfaceAST.Loop) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitLoop(node as unknown as ClassAST.Loop); }
    }
    
    weaveVarAssign(node : InterfaceAST.VarAssign) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVarAssign(node as unknown as ClassAST.VarAssign); }
    }
    
    weaveVarDecl(node : InterfaceAST.VarDecl) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVarDecl(node as unknown as ClassAST.VarDecl); }
    }
    
    weaveStatementList(node : InterfaceAST.StatementList) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitStatementList(node as unknown as ClassAST.StatementList); }
    }
    
    weaveBool(node : InterfaceAST.Bool) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBool(node as unknown as ClassAST.Bool); }
    }
    
    weaveNumber_(node : InterfaceAST.Number_) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitNumber_(node as unknown as ClassAST.Number_); }
    }
    
    weaveVoid(node : InterfaceAST.Void) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVoid(node as unknown as ClassAST.Void); }
    }
    
}