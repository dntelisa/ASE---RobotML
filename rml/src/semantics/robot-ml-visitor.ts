/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, Reference, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RobotMl language.
 */
export interface RobotMlVisitor {
    visitExpression(node : Expression) : any;
    visitFuncCall(node : FuncCall) : any;
    visitLiteral(node : Literal) : any;
    visitBoolLiteral(node : BoolLiteral) : any;
    visitNumLiteral(node : NumLiteral) : any;
    visitOperation(node : Operation) : any;
    visitBinaryOperation(node : BinaryOperation) : any;
    visitBoolBinaryOperation(node : BoolBinaryOperation) : any;
    visitNumBinaryOperation(node : NumBinaryOperation) : any;
    visitUnarOperation(node : UnarOperation) : any;
    visitBoolUnaryOperation(node : BoolUnaryOperation) : any;
    visitNumUnaryOperation(node : NumUnaryOperation) : any;
    visitPrimaryExpression(node : PrimaryExpression) : any;
    visitSensorAccess(node : SensorAccess) : any;
    visitVariableRef(node : VariableRef) : any;
    visitFuncDecl(node : FuncDecl) : any;
    visitProgramme(node : Programme) : any;
    visitStatement(node : Statement) : any;
    visitCommand(node : Command) : any;
    visitClock(node : Clock) : any;
    visitMovement(node : Movement) : any;
    visitSetSpeed(node : SetSpeed) : any;
    visitControlStructure(node : ControlStructure) : any;
    visitConditional(node : Conditional) : any;
    visitLoop(node : Loop) : any;
    visitVarAssign(node : VarAssign) : any;
    visitVarDecl(node : VarDecl) : any;
    visitStatementList(node : StatementList) : any;
    visitType(node : Type) : any;
    visitTypeVar(node : TypeVar) : any;
    visitBool(node : Bool) : any;
    visitNumber_(node : Number_) : any;
    visitVoid(node : Void) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RobotMl language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RobotMlValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: Programme, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitExpression(node : Expression) : any;
    abstract visitFuncCall(node : FuncCall) : any;
    abstract visitLiteral(node : Literal) : any;
    abstract visitBoolLiteral(node : BoolLiteral) : any;
    abstract visitNumLiteral(node : NumLiteral) : any;
    abstract visitOperation(node : Operation) : any;
    abstract visitBinaryOperation(node : BinaryOperation) : any;
    abstract visitBoolBinaryOperation(node : BoolBinaryOperation) : any;
    abstract visitNumBinaryOperation(node : NumBinaryOperation) : any;
    abstract visitUnarOperation(node : UnarOperation) : any;
    abstract visitBoolUnaryOperation(node : BoolUnaryOperation) : any;
    abstract visitNumUnaryOperation(node : NumUnaryOperation) : any;
    abstract visitPrimaryExpression(node : PrimaryExpression) : any;
    abstract visitSensorAccess(node : SensorAccess) : any;
    abstract visitVariableRef(node : VariableRef) : any;
    abstract visitFuncDecl(node : FuncDecl) : any;
    abstract visitProgramme(node : Programme) : any;
    abstract visitStatement(node : Statement) : any;
    abstract visitCommand(node : Command) : any;
    abstract visitClock(node : Clock) : any;
    abstract visitMovement(node : Movement) : any;
    abstract visitSetSpeed(node : SetSpeed) : any;
    abstract visitControlStructure(node : ControlStructure) : any;
    abstract visitConditional(node : Conditional) : any;
    abstract visitLoop(node : Loop) : any;
    abstract visitVarAssign(node : VarAssign) : any;
    abstract visitVarDecl(node : VarDecl) : any;
    abstract visitStatementList(node : StatementList) : any;
    abstract visitType(node : Type) : any;
    abstract visitTypeVar(node : TypeVar) : any;
    abstract visitBool(node : Bool) : any;
    abstract visitNumber_(node : Number_) : any;
    abstract visitVoid(node : Void) : any;
}


/**
 * This function is used to register a validation visitor for the RobotMl language.
 * It will register the `visitRoot` method as a validation check for the Programme type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RobotMlValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RobotMlAstType> = {
        Programme: (node, accept) => {
            visitor.visitRoot(node as Programme, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: RobotMlVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type FuncCall = Acceptor & Omit<ASTInterfaces.FuncCall, 'funcdecl'> & {
    funcdecl: Reference<FuncDecl>;
}

export function isFuncCall(node: unknown): node is FuncCall {
    return ASTInterfaces.isFuncCall(node) && isAcceptor(node);
}


export type Literal = Acceptor & ASTInterfaces.Literal

export function isLiteral(node: unknown): node is Literal {
    return ASTInterfaces.isLiteral(node) && isAcceptor(node);
}


export type BoolLiteral = Acceptor & ASTInterfaces.BoolLiteral

export function isBoolLiteral(node: unknown): node is BoolLiteral {
    return ASTInterfaces.isBoolLiteral(node) && isAcceptor(node);
}


export type NumLiteral = Acceptor & ASTInterfaces.NumLiteral

export function isNumLiteral(node: unknown): node is NumLiteral {
    return ASTInterfaces.isNumLiteral(node) && isAcceptor(node);
}


export type Operation = Acceptor & ASTInterfaces.Operation

export function isOperation(node: unknown): node is Operation {
    return ASTInterfaces.isOperation(node) && isAcceptor(node);
}


export type BinaryOperation = Acceptor & Omit<ASTInterfaces.BinaryOperation, 'operands'> & {
    operands: Array<Expression>;
}

export function isBinaryOperation(node: unknown): node is BinaryOperation {
    return ASTInterfaces.isBinaryOperation(node) && isAcceptor(node);
}


export type BoolBinaryOperation = Acceptor & Omit<ASTInterfaces.BoolBinaryOperation, 'operands' | 'type'> & {
    operands: Array<Expression>;
    type: BoolBOp;
}

export function isBoolBinaryOperation(node: unknown): node is BoolBinaryOperation {
    return ASTInterfaces.isBoolBinaryOperation(node) && isAcceptor(node);
}


export type NumBinaryOperation = Acceptor & Omit<ASTInterfaces.NumBinaryOperation, 'operands' | 'type'> & {
    operands: Array<Expression>;
    type: NumBOp;
}

export function isNumBinaryOperation(node: unknown): node is NumBinaryOperation {
    return ASTInterfaces.isNumBinaryOperation(node) && isAcceptor(node);
}


export type UnarOperation = Acceptor & Omit<ASTInterfaces.UnarOperation, 'operand'> & {
    operand: Expression;
}

export function isUnarOperation(node: unknown): node is UnarOperation {
    return ASTInterfaces.isUnarOperation(node) && isAcceptor(node);
}


export type BoolUnaryOperation = Acceptor & Omit<ASTInterfaces.BoolUnaryOperation, 'operand' | 'type'> & {
    operand: Expression;
    type: BoolUOp;
}

export function isBoolUnaryOperation(node: unknown): node is BoolUnaryOperation {
    return ASTInterfaces.isBoolUnaryOperation(node) && isAcceptor(node);
}


export type NumUnaryOperation = Acceptor & Omit<ASTInterfaces.NumUnaryOperation, 'operand' | 'type'> & {
    operand: Expression;
    type: NumUOp;
}

export function isNumUnaryOperation(node: unknown): node is NumUnaryOperation {
    return ASTInterfaces.isNumUnaryOperation(node) && isAcceptor(node);
}


export type PrimaryExpression = Acceptor & ASTInterfaces.PrimaryExpression

export function isPrimaryExpression(node: unknown): node is PrimaryExpression {
    return ASTInterfaces.isPrimaryExpression(node) && isAcceptor(node);
}


export type SensorAccess = Acceptor & Omit<ASTInterfaces.SensorAccess, 'sensorType'> & {
    sensorType: SensorType;
}

export function isSensorAccess(node: unknown): node is SensorAccess {
    return ASTInterfaces.isSensorAccess(node) && isAcceptor(node);
}


export type VariableRef = Acceptor & Omit<ASTInterfaces.VariableRef, 'vardecl'> & {
    vardecl: Reference<VarDecl>;
}

export function isVariableRef(node: unknown): node is VariableRef {
    return ASTInterfaces.isVariableRef(node) && isAcceptor(node);
}


export type FuncDecl = Acceptor & Omit<ASTInterfaces.FuncDecl, '$container' | 'type' | 'statementlist'> & {
    $container: Programme;
    type: Type;
    statementlist: StatementList;
}

export function isFuncDecl(node: unknown): node is FuncDecl {
    return ASTInterfaces.isFuncDecl(node) && isAcceptor(node);
}


export type Programme = Acceptor & Omit<ASTInterfaces.Programme, 'funcdecl'> & {
    funcdecl: Array<FuncDecl>;
}

export function isProgramme(node: unknown): node is Programme {
    return ASTInterfaces.isProgramme(node) && isAcceptor(node);
}


export type Statement = Acceptor & ASTInterfaces.Statement

export function isStatement(node: unknown): node is Statement {
    return ASTInterfaces.isStatement(node) && isAcceptor(node);
}


export type Command = Acceptor & ASTInterfaces.Command

export function isCommand(node: unknown): node is Command {
    return ASTInterfaces.isCommand(node) && isAcceptor(node);
}


export type Clock = Acceptor & Omit<ASTInterfaces.Clock, 'distance'> & {
    distance: Expression;
}

export function isClock(node: unknown): node is Clock {
    return ASTInterfaces.isClock(node) && isAcceptor(node);
}


export type Movement = Acceptor & Omit<ASTInterfaces.Movement, 'distance' | 'side' | 'unit'> & {
    distance: Expression;
    side: Direction;
    unit: Unit;
}

export function isMovement(node: unknown): node is Movement {
    return ASTInterfaces.isMovement(node) && isAcceptor(node);
}


export type SetSpeed = Acceptor & Omit<ASTInterfaces.SetSpeed, 'speed' | 'unit'> & {
    speed: Expression;
    unit: Unit;
}

export function isSetSpeed(node: unknown): node is SetSpeed {
    return ASTInterfaces.isSetSpeed(node) && isAcceptor(node);
}


export type ControlStructure = Acceptor & Omit<ASTInterfaces.ControlStructure, 'condition'> & {
    condition: Expression;
}

export function isControlStructure(node: unknown): node is ControlStructure {
    return ASTInterfaces.isControlStructure(node) && isAcceptor(node);
}


export type Conditional = Acceptor & Omit<ASTInterfaces.Conditional, 'condition' | 'ifBody' | 'elseBody'> & {
    condition: Expression;
    ifBody: StatementList;
    elseBody: StatementList;
}

export function isConditional(node: unknown): node is Conditional {
    return ASTInterfaces.isConditional(node) && isAcceptor(node);
}


export type Loop = Acceptor & Omit<ASTInterfaces.Loop, 'condition' | 'body'> & {
    condition: Expression;
    body: StatementList;
}

export function isLoop(node: unknown): node is Loop {
    return ASTInterfaces.isLoop(node) && isAcceptor(node);
}


export type VarAssign = Acceptor & Omit<ASTInterfaces.VarAssign, 'vardecl' | 'expression'> & {
    vardecl: Reference<VarDecl>;
    expression: Expression;
}

export function isVarAssign(node: unknown): node is VarAssign {
    return ASTInterfaces.isVarAssign(node) && isAcceptor(node);
}


export type VarDecl = Acceptor & Omit<ASTInterfaces.VarDecl, 'type' | 'expression' | 'unit'> & {
    type: TypeVar;
    expression: Expression;
    unit: Unit;
}

export function isVarDecl(node: unknown): node is VarDecl {
    return ASTInterfaces.isVarDecl(node) && isAcceptor(node);
}


export type StatementList = Acceptor & Omit<ASTInterfaces.StatementList, '$container' | 'state'> & {
    $container: FuncDecl | Conditional | Loop;
    state: Array<Statement>;
}

export function isStatementList(node: unknown): node is StatementList {
    return ASTInterfaces.isStatementList(node) && isAcceptor(node);
}


export type Type = Acceptor & ASTInterfaces.Type

export function isType(node: unknown): node is Type {
    return ASTInterfaces.isType(node) && isAcceptor(node);
}


export type TypeVar = Acceptor & ASTInterfaces.TypeVar

export function isTypeVar(node: unknown): node is TypeVar {
    return ASTInterfaces.isTypeVar(node) && isAcceptor(node);
}


export type Bool = Acceptor & ASTInterfaces.Bool

export function isBool(node: unknown): node is Bool {
    return ASTInterfaces.isBool(node) && isAcceptor(node);
}


export type Number_ = Acceptor & Omit<ASTInterfaces.Number_, 'unit'> & {
    unit: Unit;
}

export function isNumber_(node: unknown): node is Number_ {
    return ASTInterfaces.isNumber_(node) && isAcceptor(node);
}


export type Void = Acceptor & ASTInterfaces.Void

export function isVoid(node: unknown): node is Void {
    return ASTInterfaces.isVoid(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type BoolBOp = BoolBOp_EQ | BoolBOp_NEQ | BoolBOp_LEQ | BoolBOp_GEQ | BoolBOp_LE | BoolBOp_GR;

export type BoolBOp_EQ = '==';

export type BoolBOp_GEQ = '>=';

export type BoolBOp_GR = '>';

export type BoolBOp_LE = '<';

export type BoolBOp_LEQ = '<=';

export type BoolBOp_NEQ = '!=';

export type BoolUOp = BoolUOp_NOT;

export type BoolUOp_NOT = '!';

export type Direction = Direction_Backward | Direction_Forward | Direction_Sideleft | Direction_Sideright;

export type Direction_Backward = 'Backward';

export type Direction_Forward = 'Forward';

export type Direction_Sideleft = 'Sideleft';

export type Direction_Sideright = 'Sideright';

export type EBoolean = boolean;

export type EInt = number;

export type EString = string | string;

export type NumBOp = NumBOp_MINUS | NumBOp_PLUS | NumBOp_MULTIPLY | NumBOp_DIVIDE;

export type NumBOp_DIVIDE = '/';

export type NumBOp_MINUS = '-';

export type NumBOp_MULTIPLY = '*';

export type NumBOp_PLUS = '+';

export type NumUOp = NumUOp_MINUS | NumUOp_PLUS;

export type NumUOp_MINUS = '-';

export type NumUOp_PLUS = '+';

export type SensorType = SensorType_Distance | SensorType_Time | SensorType_Battery;

export type SensorType_Battery = 'getBattery';

export type SensorType_Distance = 'getDistance';

export type SensorType_Time = 'getTimestamp';

export type Unit = Unit_cm | Unit_mm;

export type Unit_cm = 'cm';

export type Unit_mm = 'mm';
