/*
 * generated by Xtext 2.40.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;
import robotML.Bool;
import robotML.BoolBinaryOperation;
import robotML.BoolLiteral;
import robotML.BoolUnaryOperation;
import robotML.Clock;
import robotML.Conditional;
import robotML.ControlStructure;
import robotML.FuncCall;
import robotML.FuncDecl;
import robotML.Loop;
import robotML.Movement;
import robotML.NumBinaryOperation;
import robotML.NumLiteral;
import robotML.NumUnaryOperation;
import robotML.Programme;
import robotML.RobotMLPackage;
import robotML.SensorAccess;
import robotML.SetSpeed;
import robotML.StatementList;
import robotML.VarAssign;
import robotML.VarDecl;
import robotML.VariableRef;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotMLPackage.BOOL:
				sequence_Bool(context, (Bool) semanticObject); 
				return; 
			case RobotMLPackage.BOOL_BINARY_OPERATION:
				sequence_BoolBinaryOperation(context, (BoolBinaryOperation) semanticObject); 
				return; 
			case RobotMLPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case RobotMLPackage.BOOL_UNARY_OPERATION:
				sequence_BoolUnaryOperation(context, (BoolUnaryOperation) semanticObject); 
				return; 
			case RobotMLPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case RobotMLPackage.CONDITIONAL:
				sequence_Conditional(context, (Conditional) semanticObject); 
				return; 
			case RobotMLPackage.CONTROL_STRUCTURE:
				sequence_ControlStructure_Impl(context, (ControlStructure) semanticObject); 
				return; 
			case RobotMLPackage.FUNC_CALL:
				sequence_FuncCall(context, (FuncCall) semanticObject); 
				return; 
			case RobotMLPackage.FUNC_DECL:
				sequence_FuncDecl(context, (FuncDecl) semanticObject); 
				return; 
			case RobotMLPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobotMLPackage.MOVEMENT:
				sequence_Movement(context, (Movement) semanticObject); 
				return; 
			case RobotMLPackage.NUM_BINARY_OPERATION:
				sequence_NumBinaryOperation(context, (NumBinaryOperation) semanticObject); 
				return; 
			case RobotMLPackage.NUM_LITERAL:
				sequence_NumLiteral(context, (NumLiteral) semanticObject); 
				return; 
			case RobotMLPackage.NUM_UNARY_OPERATION:
				sequence_NumUnaryOperation(context, (NumUnaryOperation) semanticObject); 
				return; 
			case RobotMLPackage.NUMBER:
				sequence_Number(context, (robotML.Number) semanticObject); 
				return; 
			case RobotMLPackage.PROGRAMME:
				sequence_Programme(context, (Programme) semanticObject); 
				return; 
			case RobotMLPackage.SENSOR_ACCESS:
				sequence_SensorAccess(context, (SensorAccess) semanticObject); 
				return; 
			case RobotMLPackage.SET_SPEED:
				sequence_SetSpeed(context, (SetSpeed) semanticObject); 
				return; 
			case RobotMLPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case RobotMLPackage.VAR_ASSIGN:
				sequence_VarAssign(context, (VarAssign) semanticObject); 
				return; 
			case RobotMLPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case RobotMLPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case RobotMLPackage.VOID:
				sequence_Void(context, (robotML.Void) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BoolBinaryOperation
	 *     BoolBinaryOperation returns BoolBinaryOperation
	 *
	 * Constraint:
	 *     (type=BoolBOp? operands+=Expression operands+=Expression*)
	 * </pre>
	 */
	protected void sequence_BoolBinaryOperation(ISerializationContext context, BoolBinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     val?='val'?
	 * </pre>
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BoolUnaryOperation
	 *     BoolUnaryOperation returns BoolUnaryOperation
	 *
	 * Constraint:
	 *     (type=BoolUOp? operand=Expression)
	 * </pre>
	 */
	protected void sequence_BoolUnaryOperation(ISerializationContext context, BoolUnaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Bool
	 *     TypeVar returns Bool
	 *     Bool returns Bool
	 *
	 * Constraint:
	 *     {Bool}
	 * </pre>
	 */
	protected void sequence_Bool(ISerializationContext context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Clock
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     distance=Expression
	 * </pre>
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.CLOCK__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.CLOCK__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClockAccess().getDistanceExpressionParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Conditional
	 *     Conditional returns Conditional
	 *
	 * Constraint:
	 *     (condition=Expression ifBody=StatementList elseBody=StatementList?)
	 * </pre>
	 */
	protected void sequence_Conditional(ISerializationContext context, Conditional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ControlStructure
	 *     ControlStructure_Impl returns ControlStructure
	 *
	 * Constraint:
	 *     condition=Expression
	 * </pre>
	 */
	protected void sequence_ControlStructure_Impl(ISerializationContext context, ControlStructure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.CONTROL_STRUCTURE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.CONTROL_STRUCTURE__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getControlStructure_ImplAccess().getConditionExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FuncCall
	 *     Expression returns FuncCall
	 *     FuncCall returns FuncCall
	 *
	 * Constraint:
	 *     funcdecl=[FuncDecl|EString]?
	 * </pre>
	 */
	protected void sequence_FuncCall(ISerializationContext context, FuncCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FuncDecl returns FuncDecl
	 *
	 * Constraint:
	 *     (name=EString type=Type statementlist=StatementList)
	 * </pre>
	 */
	protected void sequence_FuncDecl(ISerializationContext context, FuncDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.FUNC_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.FUNC_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.FUNC_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.FUNC_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.FUNC_DECL__STATEMENTLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.FUNC_DECL__STATEMENTLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncDeclAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFuncDeclAccess().getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFuncDeclAccess().getStatementlistStatementListParserRuleCall_6_0(), semanticObject.getStatementlist());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (condition=Expression body=StatementList)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.CONTROL_STRUCTURE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.CONTROL_STRUCTURE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopAccess().getConditionExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getLoopAccess().getBodyStatementListParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Movement
	 *     Movement returns Movement
	 *
	 * Constraint:
	 *     (side=Direction? distance=Expression)
	 * </pre>
	 */
	protected void sequence_Movement(ISerializationContext context, Movement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumBinaryOperation
	 *     NumBinaryOperation returns NumBinaryOperation
	 *
	 * Constraint:
	 *     (type=NumBOp? operands+=Expression operands+=Expression*)
	 * </pre>
	 */
	protected void sequence_NumBinaryOperation(ISerializationContext context, NumBinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumLiteral
	 *     NumLiteral returns NumLiteral
	 *
	 * Constraint:
	 *     val=EInt?
	 * </pre>
	 */
	protected void sequence_NumLiteral(ISerializationContext context, NumLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumUnaryOperation
	 *     NumUnaryOperation returns NumUnaryOperation
	 *
	 * Constraint:
	 *     (type=NumUOp? operand=Expression)
	 * </pre>
	 */
	protected void sequence_NumUnaryOperation(ISerializationContext context, NumUnaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Number
	 *     TypeVar returns Number
	 *     Number returns Number
	 *
	 * Constraint:
	 *     unit=Unit?
	 * </pre>
	 */
	protected void sequence_Number(ISerializationContext context, robotML.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Programme returns Programme
	 *
	 * Constraint:
	 *     (funcdecl+=FuncDecl funcdecl+=FuncDecl*)?
	 * </pre>
	 */
	protected void sequence_Programme(ISerializationContext context, Programme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns SensorAccess
	 *     SensorAccess returns SensorAccess
	 *
	 * Constraint:
	 *     sensorType=SensorType?
	 * </pre>
	 */
	protected void sequence_SensorAccess(ISerializationContext context, SensorAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetSpeed
	 *     SetSpeed returns SetSpeed
	 *
	 * Constraint:
	 *     speed=Expression
	 * </pre>
	 */
	protected void sequence_SetSpeed(ISerializationContext context, SetSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.SET_SPEED__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.SET_SPEED__SPEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetSpeedAccess().getSpeedExpressionParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     (state+=Statement state+=Statement*)?
	 * </pre>
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VarAssign
	 *     VarAssign returns VarAssign
	 *
	 * Constraint:
	 *     (vardecl=[VarDecl|EString]? expression=Expression)
	 * </pre>
	 */
	protected void sequence_VarAssign(ISerializationContext context, VarAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (name=EString type=TypeVar expression=Expression?)
	 * </pre>
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     vardecl=[VarDecl|EString]?
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Void
	 *     Void returns Void
	 *
	 * Constraint:
	 *     {Void}
	 * </pre>
	 */
	protected void sequence_Void(ISerializationContext context, robotML.Void semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
