// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "platform:/resource/RobotML/model/robotML.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Programme returns Programme:
	{Programme}
	'Programme'
	'{'
		('funcdecl' '{' funcdecl+=FuncDecl ( "," funcdecl+=FuncDecl)* '}' )?
	'}';


Type returns Type:
	Bool | Number | Void;


Statement returns Statement:
	FuncCall | VarAssign | VarDecl | Movement | Clock | ControlStructure_Impl | Loop | Conditional | SetSpeed;


Expression returns Expression:
	FuncCall | VariableRef | BoolLiteral | NumLiteral | BoolUnaryOperation | NumUnaryOperation | BoolBinaryOperation | NumBinaryOperation | SensorAccess;

TypeVar returns TypeVar:
	Bool | Number;

FuncDecl returns FuncDecl:
	'FuncDecl'
	name=EString
	'{'
		'type' type=Type
		'statementlist' statementlist=StatementList
	'}';

StatementList returns StatementList:
	{StatementList}
	'StatementList'
	'{'
		('state' '{' state+=Statement ( "," state+=Statement)* '}' )?
	'}';

EString returns ecore::EString:
	STRING | ID;

Bool returns Bool:
	{Bool}
	'Bool'
	;

Number returns Number:
	{Number}
	'Number'
	'{'
		('unit' unit=Unit)?
	'}';

Void returns Void:
	{Void}
	'Void'
	;

enum Unit returns Unit:
				cm = 'cm' | mm = 'mm' | none = 'none' | deg = 'deg' | rad = 'rad';

FuncCall returns FuncCall:
	{FuncCall}
	'FuncCall'
	'{'
		('funcdecl' funcdecl=[FuncDecl|EString])?
	'}';

VarAssign returns VarAssign:
	'VarAssign'
	'{'
		('vardecl' vardecl=[VarDecl|EString])?
		'expression' expression=Expression
	'}';

VarDecl returns VarDecl:
	'VarDecl'
	name=EString
	'{'
		'type' type=TypeVar
		('expression' expression=Expression)?
	'}';

Movement returns Movement:
	'Movement'
	'{'
		('side' side=Direction)?
		'distance' distance=Expression
	'}';

Clock returns Clock:
	'Clock'
	'{'
		'distance' distance=Expression
	'}';

ControlStructure_Impl returns ControlStructure:
	'ControlStructure'
	'{'
		'condition' condition=Expression
	'}';

Loop returns Loop:
	'Loop'
	'{'
		'condition' condition=Expression
		'body' body=StatementList
	'}';

Conditional returns Conditional:
	'Conditional'
	'{'
		'condition' condition=Expression
		'ifBody' ifBody=StatementList
		('elseBody' elseBody=StatementList)?
	'}';

SetSpeed returns SetSpeed:
	'SetSpeed'
	'{'
		'speed' speed=Expression
	'}';

VariableRef returns VariableRef:
	{VariableRef}
	'VariableRef'
	'{'
		('vardecl' vardecl=[VarDecl|EString])?
	'}';

BoolLiteral returns BoolLiteral:
	{BoolLiteral}
	(val?='val')?
	'BoolLiteral'
	;

NumLiteral returns NumLiteral:
	{NumLiteral}
	'NumLiteral'
	'{'
		('val' val=EInt)?
	'}';

BoolUnaryOperation returns BoolUnaryOperation:
	'BoolUnaryOperation'
	'{'
		('type' type=BoolUOp)?
		'operand' operand=Expression
	'}';

NumUnaryOperation returns NumUnaryOperation:
	'NumUnaryOperation'
	'{'
		('type' type=NumUOp)?
		'operand' operand=Expression
	'}';

BoolBinaryOperation returns BoolBinaryOperation:
	'BoolBinaryOperation'
	'{'
		('type' type=BoolBOp)?
		'operands' '{' operands+=Expression ( "," operands+=Expression)* '}' 
	'}';

NumBinaryOperation returns NumBinaryOperation:
	'NumBinaryOperation'
	'{'
		('type' type=NumBOp)?
		'operands' '{' operands+=Expression ( "," operands+=Expression)* '}' 
	'}';

SensorAccess returns SensorAccess:
	{SensorAccess}
	'SensorAccess'
	'{'
		('sensorType' sensorType=SensorType)?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EInt returns ecore::EInt:
	'-'? INT;

enum BoolUOp returns BoolUOp:
				NOT = 'NOT';

enum NumUOp returns NumUOp:
				MINUS = 'MINUS' | PLUS = 'PLUS';

enum BoolBOp returns BoolBOp:
				EQ = 'EQ' | NEQ = 'NEQ' | LEQ = 'LEQ' | GEQ = 'GEQ' | LE = 'LE' | GR = 'GR';

enum NumBOp returns NumBOp:
				MINUS = 'MINUS' | PLUS = 'PLUS' | MULTIPLY = 'MULTIPLY' | DIVIDE = 'DIVIDE';

enum SensorType returns SensorType:
				Distance = 'Distance' | Time = 'Time' | Battery = 'Battery';

enum Direction returns Direction:
				Backward = 'Backward' | Forward = 'Forward' | Sideleft = 'Sideleft' | Sideright = 'Sideright';
